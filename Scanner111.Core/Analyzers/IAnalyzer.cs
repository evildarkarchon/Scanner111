using Scanner111.Core.Models;

namespace Scanner111.Core.Analyzers;

/// <summary>
/// Interface for crash log analyzers
/// </summary>
public interface IAnalyzer
{
    /// <summary>
    /// Name of the analyzer
    /// </summary>
    string Name { get; }
    
    /// <summary>
    /// Priority of the analyzer (lower values run first)
    /// </summary>
    int Priority { get; }
    
    /// <summary>
    /// Whether this analyzer can be run in parallel with others
    /// </summary>
    bool CanRunInParallel { get; }
    
    /// <summary>
    /// Analyze a crash log asynchronously
    /// </summary>
    /// <param name="crashLog">Crash log to analyze</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Analysis result</returns>
    Task<AnalysisResult> AnalyzeAsync(CrashLog crashLog, CancellationToken cancellationToken = default);
}

/// <summary>
/// Base class for analysis results
/// </summary>
public abstract class AnalysisResult
{
    /// <summary>
    /// Name of the analyzer that produced this result
    /// </summary>
    public required string AnalyzerName { get; init; }
    
    /// <summary>
    /// True if the analysis found anything noteworthy
    /// </summary>
    public bool HasFindings { get; init; }
    
    /// <summary>
    /// True if the analysis completed successfully
    /// </summary>
    public bool Success { get; init; } = true;
    
    /// <summary>
    /// Any errors that occurred during analysis
    /// </summary>
    public IReadOnlyList<string> Errors { get; init; } = Array.Empty<string>();
    
    /// <summary>
    /// Report lines generated by the analyzer
    /// </summary>
    public List<string> ReportLines { get; init; } = new();
    
    /// <summary>
    /// Get the full report text
    /// </summary>
    public string ReportText => string.Join("", ReportLines);
}

/// <summary>
/// Generic analysis result implementation
/// </summary>
public class GenericAnalysisResult : AnalysisResult
{
    /// <summary>
    /// Additional data specific to this analysis
    /// </summary>
    public Dictionary<string, object> Data { get; init; } = new();
}

/// <summary>
/// Result from FormID analysis
/// </summary>
public class FormIdAnalysisResult : AnalysisResult
{
    /// <summary>
    /// Form IDs found in the crash log
    /// </summary>
    public List<string> FormIds { get; init; } = new();
    
    /// <summary>
    /// Resolved FormID information
    /// </summary>
    public List<FormId> ResolvedFormIds { get; init; } = new();
}

/// <summary>
/// Result from plugin analysis
/// </summary>
public class PluginAnalysisResult : AnalysisResult
{
    /// <summary>
    /// Plugins found in the crash log
    /// </summary>
    public List<Plugin> Plugins { get; init; } = new();
    
    /// <summary>
    /// Suspected problematic plugins
    /// </summary>
    public List<Plugin> SuspectedPlugins { get; init; } = new();
}

/// <summary>
/// Result from suspect pattern scanning
/// </summary>
public class SuspectAnalysisResult : AnalysisResult
{
    /// <summary>
    /// Patterns matched in error messages
    /// </summary>
    public List<string> ErrorMatches { get; init; } = new();
    
    /// <summary>
    /// Patterns matched in stack traces
    /// </summary>
    public List<string> StackMatches { get; init; } = new();
    
    /// <summary>
    /// Descriptions of matched patterns
    /// </summary>
    public List<string> MatchDescriptions { get; init; } = new();
}