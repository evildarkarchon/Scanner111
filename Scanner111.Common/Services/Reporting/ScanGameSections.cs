using Scanner111.Common.Models.GameIntegrity;
using Scanner111.Common.Models.Reporting;
using Scanner111.Common.Models.ScanGame;

namespace Scanner111.Common.Services.Reporting;

/// <summary>
/// Provides standard report section generators for ScanGame results.
/// </summary>
/// <remarks>
/// <para>
/// This static class contains methods to generate <see cref="ReportFragment"/>s
/// from various ScanGame result types. Issue messages and formatting follow
/// the patterns established in CLASSIC.
/// </para>
/// <para>
/// All section generators return empty fragments when there are no issues to report,
/// allowing for safe composition with <see cref="IReportBuilder"/>.
/// </para>
/// </remarks>
public static class ScanGameSections
{
    #region Headers and Footers

    /// <summary>
    /// Creates the main header for a ScanGame report.
    /// </summary>
    /// <param name="gameName">The display name of the game.</param>
    /// <param name="timestamp">The scan timestamp.</param>
    /// <returns>A report fragment containing the header.</returns>
    public static ReportFragment CreateMainHeader(string gameName, DateTimeOffset timestamp)
    {
        var lines = new List<string>
        {
            MarkdownFormatter.Heading($"Mod Files Scan - {gameName}", 1),
            $"Scanned: {timestamp:yyyy-MM-dd HH:mm:ss}",
            string.Empty
        };

        return ReportFragment.FromLines(lines.ToArray());
    }

    /// <summary>
    /// Creates a section header for unpacked (loose) file scan results.
    /// </summary>
    /// <returns>A report fragment containing the section header.</returns>
    public static ReportFragment CreateUnpackedSectionHeader()
    {
        var lines = new[]
        {
            MarkdownFormatter.Heading("Results from Unpacked / Loose Files", 2),
            string.Empty
        };

        return ReportFragment.FromLines(lines);
    }

    /// <summary>
    /// Creates a section header for archived (BA2) file scan results.
    /// </summary>
    /// <returns>A report fragment containing the section header.</returns>
    public static ReportFragment CreateArchivedSectionHeader()
    {
        var lines = new[]
        {
            MarkdownFormatter.Heading("Results from Archived / BA2 Files", 2),
            string.Empty
        };

        return ReportFragment.FromLines(lines);
    }

    /// <summary>
    /// Creates a section header for configuration scan results.
    /// </summary>
    /// <returns>A report fragment containing the section header.</returns>
    public static ReportFragment CreateConfigurationSectionHeader()
    {
        var lines = new[]
        {
            MarkdownFormatter.Heading("Configuration Issues", 2),
            string.Empty
        };

        return ReportFragment.FromLines(lines);
    }

    /// <summary>
    /// Creates a standard footer for ScanGame reports.
    /// </summary>
    /// <returns>A report fragment containing the footer.</returns>
    public static ReportFragment CreateFooter()
    {
        var lines = new[]
        {
            MarkdownFormatter.HorizontalRule(),
            string.Empty,
            "*This report was automatically generated by Scanner111*",
            string.Empty
        };

        return ReportFragment.FromLines(lines);
    }

    #endregion

    #region Texture Issues

    /// <summary>
    /// Creates a report section for texture dimension issues (DDS files with dimensions not divisible by 2).
    /// </summary>
    /// <param name="issues">The list of unpacked texture dimension issues.</param>
    /// <returns>A report fragment containing the formatted issues, or empty if no issues.</returns>
    public static ReportFragment CreateUnpackedTextureDimensionIssues(IReadOnlyList<UnpackedTextureDimensionIssue> issues)
    {
        if (issues.Count == 0) return new ReportFragment();

        var lines = new List<string>
        {
            string.Empty,
            MarkdownFormatter.Bold("‚ö†Ô∏è DDS DIMENSIONS ARE NOT DIVISIBLE BY 2 ‚ö†Ô∏è"),
            string.Empty,
            "> Any mods that have texture files with incorrect dimensions",
            "> are very likely to cause a *Texture (DDS) Crash*.",
            string.Empty
        };

        foreach (var issue in issues.OrderBy(i => i.RelativePath))
        {
            lines.Add($"- `{issue.RelativePath}` ({issue.Width}x{issue.Height}) - {issue.Issue}");
        }

        lines.Add(string.Empty);
        return ReportFragment.FromLines(lines.ToArray());
    }

    /// <summary>
    /// Creates a report section for archived texture dimension issues.
    /// </summary>
    /// <param name="issues">The list of archived texture dimension issues.</param>
    /// <returns>A report fragment containing the formatted issues, or empty if no issues.</returns>
    public static ReportFragment CreateArchivedTextureDimensionIssues(IReadOnlyList<TextureDimensionIssue> issues)
    {
        if (issues.Count == 0) return new ReportFragment();

        var lines = new List<string>
        {
            string.Empty,
            MarkdownFormatter.Bold("‚ö†Ô∏è DDS DIMENSIONS ARE NOT DIVISIBLE BY 2 ‚ö†Ô∏è"),
            string.Empty,
            "> Any mods that have texture files with incorrect dimensions",
            "> are very likely to cause a *Texture (DDS) Crash*.",
            string.Empty
        };

        foreach (var issue in issues.OrderBy(i => i.ArchiveName).ThenBy(i => i.TexturePath))
        {
            lines.Add($"- `{issue.ArchiveName}` ‚Üí `{issue.TexturePath}` ({issue.Width}x{issue.Height})");
        }

        lines.Add(string.Empty);
        return ReportFragment.FromLines(lines.ToArray());
    }

    /// <summary>
    /// Creates a report section for texture format issues (TGA/PNG instead of DDS).
    /// </summary>
    /// <param name="issues">The list of unpacked texture format issues.</param>
    /// <returns>A report fragment containing the formatted issues, or empty if no issues.</returns>
    public static ReportFragment CreateUnpackedTextureFormatIssues(IReadOnlyList<UnpackedTextureFormatIssue> issues)
    {
        if (issues.Count == 0) return new ReportFragment();

        var lines = new List<string>
        {
            string.Empty,
            MarkdownFormatter.Bold("‚ùì TEXTURE FILES HAVE INCORRECT FORMAT, SHOULD BE DDS ‚ùì"),
            string.Empty,
            "> Any files with an incorrect file format will not work.",
            "> Mod authors should convert these files to their proper game format.",
            string.Empty
        };

        foreach (var issue in issues.OrderBy(i => i.RelativePath))
        {
            lines.Add($"- `{issue.RelativePath}` ({issue.Extension.ToUpperInvariant()})");
        }

        lines.Add(string.Empty);
        return ReportFragment.FromLines(lines.ToArray());
    }

    /// <summary>
    /// Creates a report section for archived texture format issues.
    /// </summary>
    /// <param name="issues">The list of archived texture format issues.</param>
    /// <returns>A report fragment containing the formatted issues, or empty if no issues.</returns>
    public static ReportFragment CreateArchivedTextureFormatIssues(IReadOnlyList<TextureFormatIssue> issues)
    {
        if (issues.Count == 0) return new ReportFragment();

        var lines = new List<string>
        {
            string.Empty,
            MarkdownFormatter.Bold("‚ùì TEXTURE FILES HAVE INCORRECT FORMAT, SHOULD BE DDS ‚ùì"),
            string.Empty,
            "> Any files with an incorrect file format will not work.",
            "> Mod authors should convert these files to their proper game format.",
            string.Empty
        };

        foreach (var issue in issues.OrderBy(i => i.ArchiveName).ThenBy(i => i.TexturePath))
        {
            lines.Add($"- `{issue.ArchiveName}` ‚Üí `{issue.TexturePath}` ({issue.Extension.ToUpperInvariant()})");
        }

        lines.Add(string.Empty);
        return ReportFragment.FromLines(lines.ToArray());
    }

    #endregion

    #region Sound Issues

    /// <summary>
    /// Creates a report section for sound format issues (MP3/M4A instead of XWM/WAV).
    /// </summary>
    /// <param name="issues">The list of unpacked sound format issues.</param>
    /// <returns>A report fragment containing the formatted issues, or empty if no issues.</returns>
    public static ReportFragment CreateUnpackedSoundFormatIssues(IReadOnlyList<UnpackedSoundFormatIssue> issues)
    {
        if (issues.Count == 0) return new ReportFragment();

        var lines = new List<string>
        {
            string.Empty,
            MarkdownFormatter.Bold("‚ùì SOUND FILES HAVE INCORRECT FORMAT, SHOULD BE XWM OR WAV ‚ùì"),
            string.Empty,
            "> Any files with an incorrect file format will not work.",
            "> Mod authors should convert these files to their proper game format.",
            string.Empty
        };

        foreach (var issue in issues.OrderBy(i => i.RelativePath))
        {
            lines.Add($"- `{issue.RelativePath}` ({issue.Extension.ToUpperInvariant()})");
        }

        lines.Add(string.Empty);
        return ReportFragment.FromLines(lines.ToArray());
    }

    /// <summary>
    /// Creates a report section for archived sound format issues.
    /// </summary>
    /// <param name="issues">The list of archived sound format issues.</param>
    /// <returns>A report fragment containing the formatted issues, or empty if no issues.</returns>
    public static ReportFragment CreateArchivedSoundFormatIssues(IReadOnlyList<SoundFormatIssue> issues)
    {
        if (issues.Count == 0) return new ReportFragment();

        var lines = new List<string>
        {
            string.Empty,
            MarkdownFormatter.Bold("‚ùì SOUND FILES HAVE INCORRECT FORMAT, SHOULD BE XWM OR WAV ‚ùì"),
            string.Empty,
            "> Any files with an incorrect file format will not work.",
            "> Mod authors should convert these files to their proper game format.",
            string.Empty
        };

        foreach (var issue in issues.OrderBy(i => i.ArchiveName).ThenBy(i => i.SoundPath))
        {
            lines.Add($"- `{issue.ArchiveName}` ‚Üí `{issue.SoundPath}` ({issue.Extension.ToUpperInvariant()})");
        }

        lines.Add(string.Empty);
        return ReportFragment.FromLines(lines.ToArray());
    }

    #endregion

    #region XSE File Issues

    /// <summary>
    /// Creates a report section for unpacked XSE script file issues.
    /// </summary>
    /// <param name="issues">The list of unpacked XSE file issues.</param>
    /// <param name="xseAcronym">The XSE acronym (e.g., "F4SE", "SKSE").</param>
    /// <returns>A report fragment containing the formatted issues, or empty if no issues.</returns>
    public static ReportFragment CreateUnpackedXseFileIssues(IReadOnlyList<UnpackedXseFileIssue> issues, string xseAcronym)
    {
        if (issues.Count == 0) return new ReportFragment();

        var lines = new List<string>
        {
            string.Empty,
            MarkdownFormatter.Bold($"‚ö†Ô∏è FOLDERS CONTAIN COPIES OF *{xseAcronym}* SCRIPT FILES ‚ö†Ô∏è"),
            string.Empty,
            "> Any mods with copies of original Script Extender files",
            "> may cause script related problems or crashes.",
            string.Empty
        };

        foreach (var issue in issues.OrderBy(i => i.RelativePath))
        {
            lines.Add($"- `{issue.RelativePath}`");
        }

        lines.Add(string.Empty);
        return ReportFragment.FromLines(lines.ToArray());
    }

    /// <summary>
    /// Creates a report section for archived XSE script file issues.
    /// </summary>
    /// <param name="issues">The list of archived XSE file issues.</param>
    /// <param name="xseAcronym">The XSE acronym (e.g., "F4SE", "SKSE").</param>
    /// <returns>A report fragment containing the formatted issues, or empty if no issues.</returns>
    public static ReportFragment CreateArchivedXseFileIssues(IReadOnlyList<XseFileIssue> issues, string xseAcronym)
    {
        if (issues.Count == 0) return new ReportFragment();

        var lines = new List<string>
        {
            string.Empty,
            MarkdownFormatter.Bold($"‚ö†Ô∏è BA2 ARCHIVES CONTAIN COPIES OF *{xseAcronym}* SCRIPT FILES ‚ö†Ô∏è"),
            string.Empty,
            "> Any mods with copies of original Script Extender files",
            "> may cause script related problems or crashes.",
            string.Empty
        };

        foreach (var issue in issues.OrderBy(i => i.ArchiveName))
        {
            lines.Add($"- `{issue.ArchiveName}`");
        }

        lines.Add(string.Empty);
        return ReportFragment.FromLines(lines.ToArray());
    }

    #endregion

    #region Unpacked-Specific Issues

    /// <summary>
    /// Creates a report section for previs/precombine file issues.
    /// </summary>
    /// <param name="issues">The list of previs file issues.</param>
    /// <returns>A report fragment containing the formatted issues, or empty if no issues.</returns>
    public static ReportFragment CreatePrevisFileIssues(IReadOnlyList<PrevisFileIssue> issues)
    {
        if (issues.Count == 0) return new ReportFragment();

        var lines = new List<string>
        {
            string.Empty,
            MarkdownFormatter.Bold("‚ö†Ô∏è FOLDERS CONTAIN LOOSE PRECOMBINE / PREVIS FILES ‚ö†Ô∏è"),
            string.Empty,
            "> Any mods that contain custom precombine/previs files",
            "> should load after the PRP.esp plugin from Previs Repair Pack (PRP).",
            "> Otherwise, see if there is a PRP patch available for these mods.",
            string.Empty
        };

        foreach (var issue in issues.OrderBy(i => i.RelativePath))
        {
            lines.Add($"- `{issue.RelativePath}`");
        }

        lines.Add(string.Empty);
        return ReportFragment.FromLines(lines.ToArray());
    }

    /// <summary>
    /// Creates a report section for animation data issues.
    /// </summary>
    /// <param name="issues">The list of animation data issues.</param>
    /// <returns>A report fragment containing the formatted issues, or empty if no issues.</returns>
    public static ReportFragment CreateAnimationDataIssues(IReadOnlyList<AnimationDataIssue> issues)
    {
        if (issues.Count == 0) return new ReportFragment();

        var lines = new List<string>
        {
            string.Empty,
            MarkdownFormatter.Bold("‚ùì FOLDERS CONTAIN CUSTOM ANIMATION FILE DATA ‚ùì"),
            string.Empty,
            "> Any mods that have their own custom Animation File Data",
            "> may rarely cause an *Animation Corruption Crash*.",
            string.Empty
        };

        foreach (var issue in issues.OrderBy(i => i.RelativePath))
        {
            lines.Add($"- `{issue.RelativePath}`");
        }

        lines.Add(string.Empty);
        return ReportFragment.FromLines(lines.ToArray());
    }

    /// <summary>
    /// Creates a report section for cleanup issues (readme files, FOMOD folders).
    /// </summary>
    /// <param name="issues">The list of cleanup issues.</param>
    /// <returns>A report fragment containing the formatted issues, or empty if no issues.</returns>
    public static ReportFragment CreateCleanupIssues(IReadOnlyList<CleanupIssue> issues)
    {
        if (issues.Count == 0) return new ReportFragment();

        var lines = new List<string>
        {
            string.Empty,
            MarkdownFormatter.Bold("üìÑ DOCUMENTATION FILES THAT CAN BE REMOVED üìÑ"),
            string.Empty
        };

        foreach (var issue in issues.OrderBy(i => i.RelativePath))
        {
            var typeStr = issue.ItemType == CleanupItemType.FomodFolder ? "(FOMOD folder)" : "(readme file)";
            lines.Add($"- `{issue.RelativePath}` {typeStr}");
        }

        lines.Add(string.Empty);
        return ReportFragment.FromLines(lines.ToArray());
    }

    #endregion

    #region BA2-Specific Issues

    /// <summary>
    /// Creates a report section for BA2 format issues (invalid headers).
    /// </summary>
    /// <param name="issues">The list of BA2 format issues.</param>
    /// <returns>A report fragment containing the formatted issues, or empty if no issues.</returns>
    public static ReportFragment CreateBA2FormatIssues(IReadOnlyList<BA2FormatIssue> issues)
    {
        if (issues.Count == 0) return new ReportFragment();

        var lines = new List<string>
        {
            string.Empty,
            MarkdownFormatter.Bold("‚ùì BA2 ARCHIVES HAVE INCORRECT FORMAT, SHOULD BE BTDX-GNRL OR BTDX-DX10 ‚ùì"),
            string.Empty,
            "> Any files with an incorrect file format will not work.",
            "> Mod authors should convert these files to their proper game format.",
            string.Empty
        };

        foreach (var issue in issues.OrderBy(i => i.ArchiveName))
        {
            lines.Add($"- `{issue.ArchiveName}` (header: {issue.HeaderBytes})");
        }

        lines.Add(string.Empty);
        return ReportFragment.FromLines(lines.ToArray());
    }

    #endregion

    #region Configuration Issues

    /// <summary>
    /// Creates a report section for INI configuration issues.
    /// </summary>
    /// <param name="issues">The list of configuration issues.</param>
    /// <returns>A report fragment containing the formatted issues, or empty if no issues.</returns>
    public static ReportFragment CreateConfigIssues(IReadOnlyList<ConfigIssue> issues)
    {
        if (issues.Count == 0) return new ReportFragment();

        var lines = new List<string>
        {
            string.Empty,
            MarkdownFormatter.Bold("‚ö†Ô∏è INI CONFIGURATION ISSUES ‚ö†Ô∏è"),
            string.Empty
        };

        // Group by severity
        var errorIssues = issues.Where(i => i.Severity == ConfigIssueSeverity.Error).ToList();
        var warningIssues = issues.Where(i => i.Severity == ConfigIssueSeverity.Warning).ToList();
        var infoIssues = issues.Where(i => i.Severity == ConfigIssueSeverity.Info).ToList();

        if (errorIssues.Count > 0)
        {
            lines.Add("**Errors:**");
            foreach (var issue in errorIssues.OrderBy(i => i.FileName))
            {
                lines.Add($"- `{issue.FileName}` [{issue.Section}] {issue.Setting} = {issue.CurrentValue}");
                lines.Add($"  ‚Üí Recommended: {issue.RecommendedValue} - {issue.Description}");
            }
            lines.Add(string.Empty);
        }

        if (warningIssues.Count > 0)
        {
            lines.Add("**Warnings:**");
            foreach (var issue in warningIssues.OrderBy(i => i.FileName))
            {
                lines.Add($"- `{issue.FileName}` [{issue.Section}] {issue.Setting} = {issue.CurrentValue}");
                lines.Add($"  ‚Üí Recommended: {issue.RecommendedValue} - {issue.Description}");
            }
            lines.Add(string.Empty);
        }

        if (infoIssues.Count > 0)
        {
            lines.Add("**Info:**");
            foreach (var issue in infoIssues.OrderBy(i => i.FileName))
            {
                lines.Add($"- `{issue.FileName}` [{issue.Section}] {issue.Setting} = {issue.CurrentValue}");
                lines.Add($"  ‚Üí Recommended: {issue.RecommendedValue} - {issue.Description}");
            }
            lines.Add(string.Empty);
        }

        return ReportFragment.FromLines(lines.ToArray());
    }

    /// <summary>
    /// Creates a report section for TOML configuration issues.
    /// </summary>
    /// <param name="result">The TOML scan result.</param>
    /// <returns>A report fragment containing the formatted issues, or empty if no issues.</returns>
    public static ReportFragment CreateTomlIssues(TomlScanResult result)
    {
        if (!result.HasIssues) return new ReportFragment();

        var lines = new List<string>
        {
            string.Empty,
            MarkdownFormatter.Bold($"‚ö†Ô∏è {result.CrashGenName.ToUpperInvariant()} CONFIGURATION ISSUES ‚ö†Ô∏è"),
            string.Empty
        };

        if (!result.ConfigFileFound)
        {
            lines.Add($"> {result.CrashGenName} configuration file not found.");
            lines.Add(string.Empty);
        }
        else if (result.HasDuplicateConfigs)
        {
            lines.Add($"> Multiple {result.CrashGenName} configuration files detected. This may cause conflicts.");
            lines.Add(string.Empty);
        }

        if (result.ConfigIssues.Count > 0)
        {
            foreach (var issue in result.ConfigIssues.OrderBy(i => i.Setting))
            {
                lines.Add($"- [{issue.Section}] {issue.Setting} = {issue.CurrentValue}");
                lines.Add($"  ‚Üí Recommended: {issue.RecommendedValue} - {issue.Description}");
            }
            lines.Add(string.Empty);
        }

        return ReportFragment.FromLines(lines.ToArray());
    }

    #endregion

    #region XSE Status Issues

    /// <summary>
    /// Creates a report section for XSE installation status issues.
    /// </summary>
    /// <param name="result">The XSE scan result.</param>
    /// <param name="xseAcronym">The XSE acronym (e.g., "F4SE", "SKSE").</param>
    /// <returns>A report fragment containing the formatted issues, or empty if no issues.</returns>
    public static ReportFragment CreateXseStatusIssues(XseScanResult result, string xseAcronym)
    {
        if (!result.HasIssues) return new ReportFragment();

        var lines = new List<string>
        {
            string.Empty,
            MarkdownFormatter.Bold($"‚ö†Ô∏è {xseAcronym} STATUS ‚ö†Ô∏è"),
            string.Empty
        };

        if (!result.AddressLibraryInstalled)
        {
            lines.Add($"- Address Library is NOT installed. Many {xseAcronym} plugins require this.");
        }

        if (!result.XseInstalled)
        {
            lines.Add($"- {xseAcronym} is NOT installed or has never been run.");
        }
        else if (!result.IsLatestVersion)
        {
            var version = result.DetectedVersion ?? "unknown";
            lines.Add($"- {xseAcronym} version {version} is outdated. Please update to the latest version.");
        }

        if (result.LogErrors.Count > 0)
        {
            lines.Add(string.Empty);
            lines.Add($"**{xseAcronym} Log Errors:**");
            foreach (var error in result.LogErrors.Take(10)) // Limit to 10
            {
                lines.Add($"- Line {error.LineNumber}: {error.ErrorText}");
            }

            if (result.LogErrors.Count > 10)
            {
                lines.Add($"- ... and {result.LogErrors.Count - 10} more errors");
            }
        }

        if (result.ScriptHashResults.Any(s => s.Status != ScriptHashStatus.Valid))
        {
            lines.Add(string.Empty);
            lines.Add("**Script File Issues:**");
            foreach (var script in result.ScriptHashResults.Where(s => s.Status != ScriptHashStatus.Valid))
            {
                var statusStr = script.Status switch
                {
                    ScriptHashStatus.Missing => "MISSING",
                    ScriptHashStatus.Mismatch => "MODIFIED",
                    ScriptHashStatus.ReadError => "UNREADABLE",
                    _ => script.Status.ToString()
                };
                lines.Add($"- `{script.FileName}`: {statusStr}");
            }
        }

        lines.Add(string.Empty);
        return ReportFragment.FromLines(lines.ToArray());
    }

    #endregion

    #region Game Integrity Issues

    /// <summary>
    /// Creates a report section for game integrity issues.
    /// </summary>
    /// <param name="result">The game integrity result.</param>
    /// <returns>A report fragment containing the formatted issues, or empty if no issues.</returns>
    public static ReportFragment CreateGameIntegrityIssues(GameIntegrityResult result)
    {
        if (!result.HasIssues) return new ReportFragment();

        var lines = new List<string>
        {
            string.Empty,
            MarkdownFormatter.Bold("‚ö†Ô∏è GAME INSTALLATION ISSUES ‚ö†Ô∏è"),
            string.Empty
        };

        foreach (var issue in result.Issues)
        {
            var severityIcon = issue.Severity switch
            {
                ConfigIssueSeverity.Error => "‚ùå",
                ConfigIssueSeverity.Warning => "‚ö†Ô∏è",
                _ => "‚ÑπÔ∏è"
            };

            lines.Add($"{severityIcon} {issue.Message}");
            if (!string.IsNullOrEmpty(issue.Recommendation))
            {
                lines.Add($"  ‚Üí {issue.Recommendation}");
            }
        }

        lines.Add(string.Empty);
        return ReportFragment.FromLines(lines.ToArray());
    }

    #endregion

    #region No Issues Section

    /// <summary>
    /// Creates a success message when no issues were found.
    /// </summary>
    /// <returns>A report fragment containing the success message.</returns>
    public static ReportFragment CreateNoIssuesFound()
    {
        var lines = new[]
        {
            string.Empty,
            "‚úÖ **No issues found!** Your mod setup looks good.",
            string.Empty
        };

        return ReportFragment.FromLines(lines);
    }

    #endregion
}
