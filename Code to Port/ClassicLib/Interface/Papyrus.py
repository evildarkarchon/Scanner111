from dataclasses import dataclass
from datetime import datetime

from PySide6.QtCore import QMutex, QObject, QThread, Signal, Slot

from ClassicLib.PapyrusLog import papyrus_logging


@dataclass
class PapyrusStats:
    """
    Represents statistics associated with Papyrus, including performance and
    error metrics.

    This class is designed to encapsulate various statistics related to Papyrus,
    such as the number of dumps, stacks, warnings, errors, and a calculated ratio.
    It also provides equality comparison based on specific attributes.

    Attributes:
        timestamp (datetime): The timestamp indicating when the statistics were
            recorded.
        dumps (int): The number of dumps processed or analyzed.
        stacks (int): The number of stacks involved or recorded.
        warnings (int): The number of warnings encountered.
        errors (int): The number of errors encountered.
        ratio (float): A calculated ratio or metric based on other statistics.
    """

    timestamp: datetime
    dumps: int
    stacks: int
    warnings: int
    errors: int
    ratio: float

    def __eq__(self, other: object) -> bool:
        """
        Compares this `PapyrusStats` instance for equality with another object.

        The equality is determined based on the attribute values of `dumps`,
        `stacks`, `warnings`, and `errors`. If the other object is not an
        instance of `PapyrusStats`, the comparison returns `NotImplemented`.

        Args:
            other (object): The object to compare against this instance.

        Returns:
            bool: True if the `PapyrusStats` objects are equal by comparing
            their attributes; False otherwise. If the `other` is not a
            `PapyrusStats` instance, this method returns `NotImplemented`.
        """
        if not isinstance(other, PapyrusStats):
            return NotImplemented
        return self.dumps == other.dumps and self.stacks == other.stacks and self.warnings == other.warnings and self.errors == other.errors

    def __hash__(self) -> int:
        """
        Returns a hash value for this `PapyrusStats` instance.

        The hash is computed based on the same attributes used for equality
        comparison: `dumps`, `stacks`, `warnings`, and `errors`. This ensures
        that instances that compare equal will have the same hash value.

        Returns:
            int: The hash value for this instance.
        """
        return hash((self.dumps, self.stacks, self.warnings, self.errors))


class PapyrusMonitorWorker(QObject):
    """
    Handles monitoring and analysis of logging stats generated by the Papyrus system.

    This class is designed to interact with the `CGame` module for retrieving real-time
    logging updates. It processes these updates to extract vital statistics, emits signals
    for data updates, and handles errors gracefully. It also includes mechanisms to control
    the monitoring lifecycle and parse diagnostic messages.

    Attributes:
        statsUpdated (Signal): A Qt signal that emits an instance of PapyrusStats whenever
            new statistics are successfully parsed and detected as updated.
        error (Signal): A Qt signal that emits a string representation of an error
            message when an exception occurs during the monitoring process.
    """

    # Signal when new stats are available
    statsUpdated: Signal = Signal(PapyrusStats)

    # Signal for errors
    error: Signal = Signal(str)

    # noinspection GrazieInspection
    def __init__(self) -> None:
        """
        Initializes the CLASSIC_Interface instance.

        This constructor sets up the initial state of the instance, including:
        - Setting the `_should_run` flag to True.
        - Initializing `_last_stats` to None.
        - Initializing `error_sound_played` to False to track if the error sound has played this session.
        - Creating a mutex for thread-safe access to _should_run.
        """
        super().__init__()
        self._should_run = True
        self._should_run_mutex = QMutex()
        self._last_stats: PapyrusStats | None = None
        self.error_sound_played = False  # Track if error sound has played this session

    def stop(self) -> None:
        """
        Stops the running process controlled by this method. This method sets an internal
        flag indicating that the process should no longer continue, without raising errors
        or exceptions. Thread-safe implementation using mutex.

        This function modifies the state of the instance to indicate that the process or
        operation managed by this method should be halted. The actual stopping logic or
        implementation might need to check this internal flag periodically.

        Raises:
            None: The method does not raise any exceptions.

        Returns:
            None: There are no return values for this method.
        """
        self._should_run_mutex.lock()
        try:
            self._should_run = False
        finally:
            self._should_run_mutex.unlock()

    @Slot()
    def run(self) -> None:
        """
        Main monitoring loop.

        This loop continuously monitors for updates from the `CGame` logging function.
        It parses the retrieved log messages to extract stats and emits a signal when
        a change in stats is detected. If an error occurs during the monitoring process,
        the loop will emit an error signal and terminate.

        Raises:
            OSError: Raised when there is an issue accessing the logging resource or
                underlying I/O operations.
            ValueError: Raised when the message content or count is invalid or can't
                be processed.

        Emits:
            statsUpdated: This signal is emitted with the current stats whenever a
                change in stats is detected.
            error: This signal is emitted with a string representation of the error
                when an exception occurs during execution.

        """
        """Main monitoring loop"""
        while True:
            # Thread-safe check of _should_run
            self._should_run_mutex.lock()
            should_continue = self._should_run
            self._should_run_mutex.unlock()

            if not should_continue:
                break

            try:
                message, count = papyrus_logging()

                # Parse the message to extract stats
                current_stats: PapyrusStats = self._parse_stats(message, count)

                # Only emit if stats have changed
                if self._last_stats != current_stats:
                    self.statsUpdated.emit(current_stats)
                    self._last_stats = current_stats

                # Sleep for a short interval to prevent excessive CPU usage
                QThread.msleep(1000)  # Check every second

            except (OSError, ValueError) as e:
                self.error.emit(str(e))
                break

    @staticmethod
    def _parse_stats(message: str, dump_count: int) -> PapyrusStats:
        """
        Parses a diagnostic message to gather statistics about dumps, stacks,
        warnings, errors, and calculates the dump-to-stack ratio.

        This method processes the provided diagnostic message, extracting values
        like the number of dumps, stacks, warnings, and errors. It then calculates
        the ratio of dumps to stacks for further analysis.

        Args:
            message: A string containing the diagnostic information where various
                statistics are mentioned in a specific format.
            dump_count: An integer that represents the total number of dumps.

        Returns:
            An instance of PapyrusStats that encapsulates the parsed statistics
            (including the timestamp of parsing, number of dumps, stacks, warnings,
            errors, and the calculated dump-to-stack ratio).
        """
        stats: dict[str, int] = {"dumps": dump_count, "stacks": 0, "warnings": 0, "errors": 0}

        for line in message.splitlines():
            if ": " in line:
                key, value = line.split(": ")
                key = key.strip().lower()
                if key == "number of stacks":
                    stats["stacks"] = int(value)
                elif key == "number of warnings":
                    stats["warnings"] = int(value)
                elif key == "number of errors":
                    stats["errors"] = int(value)

        ratio: float = 0.0 if stats["dumps"] == 0 else stats["dumps"] / stats["stacks"]

        return PapyrusStats(
            timestamp=datetime.now(),
            dumps=stats["dumps"],
            stacks=stats["stacks"],
            warnings=stats["warnings"],
            errors=stats["errors"],
            ratio=ratio,
        )
